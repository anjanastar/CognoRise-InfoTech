# -*- coding: utf-8 -*-
"""cereals.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zc57xOvVyG3-_ofJubxXKX04pqJOQQnE
"""



from mpl_toolkits.mplot3d import Axes3D
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt # plotting
import numpy as np # linear algebra
import os # accessing directory structure
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

df1 = pd.read_csv('/cereals.csv')

df1.head(5)

df1.info()

df1.describe()

df1[df1['carbo'] == -1]
carbo_med_Q = df1[df1['mfr'] == 'Q']['carbo'].median()

df1['carbo'] = df1['carbo'].replace(-1, carbo_med_Q)
#df[df['mfr'] == 'Q']

df1[df1['potass'] == -1]

potass_med_R = df1[df1['mfr'] == 'R']['potass'].median()
potass_med_R

df1.loc[(df1['mfr'] == 'R') & (df1['potass'] == -1), 'potass'] = potass_med_R

potass_med_H = df1[df1['mfr'] == 'N']['potass'].median()
potass_med_H

df1.loc[(df1['mfr'] == 'N') & (df1['potass'] == -1), 'potass'] = potass_med_H

df1[df1['sugars'] == -1]
sugars_med_H = df1[df1['mfr'] == 'Q']['sugars'].median()

df1['sugars'] = df1['sugars'].replace(-1, sugars_med_H)
#df[df['mfr'] == 'Q']

df1.describe()

df1['mfr'].value_counts()

name_dict = {'A' : 'American Home Food Products',
            'G' : 'General Mills',
            'K' : 'Kelloggs',
            'N' : 'Nabisco',
            'P' : 'Post',
            'Q' : 'Quaker Oats',
            'R' : 'Ralston Purina'}

df1['man_name'] = df1['mfr'].map(name_dict)

col_order = ['name', 'mfr', 'man_name', 'type', 'calories', 'protein', 'fat', 'sodium', 'fiber', 'carbo', \
             'sugars', 'potass', 'vitamins', 'shelf', 'weight', 'cups', 'rating']

df = df1.reindex(columns=col_order)
df.sort_values(by='rating', ascending=False)

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import warnings
warnings.filterwarnings("ignore")
# %matplotlib inline

sns.set(palette='deep')
plt.figure(figsize=(8, 3))
sns.boxplot(data=df, x='man_name', y='rating')
plt.xticks(rotation=90)
plt.title('Rating of product by Manufacturer')
plt.xlabel("Manufacturer's name")

plt.show()

df_anova = df[(df['mfr'] != 'N') & (df['mfr'] != 'A')]
df_anova['mfr'].value_counts()

import warnings
warnings.filterwarnings("ignore")

#display(df.groupby('shelf')['man_name'].value_counts())
df.groupby('shelf')['rating'].agg([np.mean, np.std, np.min, np.max])

shelf_1 = df[df['shelf']  == 1]
mean_rating_1 = shelf_1['rating'].mean()
std_rating_1 = shelf_1['rating'].std()

shelf_1['z_score'] = (shelf_1['rating'] - mean_rating_1) / std_rating_1
shelf_1.sort_values(by=['z_score'], ascending=False).head()

shelf_2 = df[df['shelf'] == 2]
mean_rating_2 = shelf_2['rating'].mean()
std_rating_2 = shelf_2['rating'].std()
shelf_2['z_score'] = (shelf_2['rating'] - mean_rating_2) / std_rating_2
shelf_2.sort_values(by=['z_score'], ascending=False).head()

shelf_3 = df[df['shelf'] == 3]
mean_rating_3 = shelf_3['rating'].mean()
std_rating_3 = shelf_3['rating'].std()
shelf_3['z_score'] = (shelf_3['rating'] - mean_rating_3) / std_rating_3
shelf_3.sort_values(by=['z_score'], ascending=False).head()

shelf_1_count = shelf_1['man_name'].value_counts()
shelf_1_count = pd.DataFrame(shelf_1_count)
shelf_1_count.columns = ['shelf_1']

shelf_2_count = shelf_2['man_name'].value_counts()
shelf_2_count = pd.DataFrame(shelf_2_count)
shelf_2_count.columns = ['shelf_2']

shelf_3_count = shelf_3['man_name'].value_counts()
shelf_3_count = pd.DataFrame(shelf_3_count)
shelf_3_count.columns = ['shelf_3']

pivot_table = pd.concat([shelf_1_count, shelf_2_count, shelf_3_count], axis=1, sort=False)
pivot_table['total'] = pivot_table.sum(axis=1)
pivot_table

df.groupby('shelf')[['calories', 'protein', 'fat', 'sodium', 'fiber', 'carbo',\
                    'sugars', 'potass', 'vitamins', 'weight', 'cups', 'rating']].mean()

cols = ['calories', 'protein', 'fat', 'sodium', 'fiber', 'carbo', 'sugars', 'potass', 'vitamins','rating']

df_num = df.loc[:, cols]
df_num

corr_matrix = df_num.corr()

plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True)
plt.title('Correlation between numerical values')
plt.show()

# This code below lets me investigate the correlation between rating and specific nutrients and to isolate
# for the different manufacturers.

from scipy.stats import pearsonr
x_var = df['fiber'] # Change this value to any nutrient I want to investigate.
y_var = df['rating']

sns.scatterplot(data=df, x=x_var, y=y_var, hue='man_name')
r, p_value = pearsonr(x_var, y_var)

plt.title('Scatterplot of nutrient and rating')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.75))

df.loc[df['fiber'].idxmax()]

df_tl = df[['name', 'man_name', 'fat', 'sugars', 'sodium']]

df_tl

thresholds = {
    'fat': {'green': 3, 'amber': 17.5 },
    'sugars': {'green': 5, 'amber': 22.5 },
    'sodium': {'green': 300.0, 'amber': 1500.0 } # converted grams into milligrams
}

# In the dataframe the nutrients are measured in grams or milligrams, and the weight of one serving is in ounces
# but my thresholds are in 100 grams,therefore I need to convert my thresholds based on one serving.

# 1 ounce = 28.3495 grams
# 100 grams / 28.3495 = 3.527, divided each value in thresholds above by 3.527 so all threshold values are consistent with values in dataframe.

converted_thresholds = {
    'fat' : {'green' : 0.850, 'amber': 4.962},
    'sugars': {'green': 1.418, 'amber': 6.379},
    'sodium': {'green': 85.058, 'amber': 425.29}
}


def assign_color(value, nutrient):
    for color, threshold in converted_thresholds[nutrient].items():
        if value <= threshold:
            return color
    return 'red'

# Chat GPT helped me a bit here.
# Apply the mapping to the 'fat', 'sugars', and 'sodium' columns using .loc[]
df_tl.loc[:, 'color_fat'] = df_tl.apply(lambda row: assign_color(row['fat'], 'fat'), axis=1)
df_tl.loc[:, 'color_sugars'] = df_tl.apply(lambda row: assign_color(row['sugars'], 'sugars'), axis=1)
df_tl.loc[:, 'color_sodium'] = df_tl.apply(lambda row: assign_color(row['sodium'], 'sodium'), axis=1)

# Need to run this cell twice for it to work.

col_order = ['name', 'man_name', 'fat', 'color_fat', 'sugars', 'color_sugars', 'sodium', 'color_sodium']

df_tl = df_tl.reindex(columns=col_order)
df_tl

# I can now quickly quickly check how healthy individual cerials are by using the code below.
#df_tl[df_tl['name'] == 'Cocoa Puffs'] # change

colors = ['y', 'g', 'r']

df_tl_fat = df_tl.groupby(['man_name', 'color_fat'])['color_fat'].count().unstack()
df_tl_sugars = df_tl.groupby(['man_name', 'color_sugars'])['color_sugars'].count().unstack()
df_tl_sodium = df_tl.groupby(['man_name', 'color_sodium'])['color_sodium'].count().unstack()

fig, axes = plt.subplots(1, 3, figsize=(14, 5))

df_tl_fat.plot(kind='bar', stacked=True, color=colors, ax=axes[0])
axes[0].set_title('Traffic light count by Fat')
axes[0].set_xlabel('Manufacturers')

df_tl_sugars.plot(kind='bar', stacked=True, color=colors, ax=axes[1])
axes[1].set_title('Traffic light count by Sugar')
axes[1].set_xlabel('Manufacturers')

df_tl_sodium.plot(kind='bar', stacked=True, color=colors, ax=axes[2])
axes[2].set_title('Traffic light count by Sodium')
axes[2].set_xlabel('Manufacturers')

fig.suptitle('Stacked Bar Charts of Manufacturer by traffic light colour', fontsize=16)

plt.show()